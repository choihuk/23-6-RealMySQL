# 인덱스

## 8.2 인덱스란?

칼럼의 값과 해당 레코드가 저장된 주소를 key-value형태로 저장한다.

데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다.

인덱스로 생성하는 칼럼이 많으면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져 역효과를 불러올 수 있다.

인덱스는 프라이머리 키와 세컨더리 인덱스로 구분할 수 있다.

- 프라이머리 키: 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스. 즉 식별자로 만들어진 인덱스이다.
- 세컨더리 인덱스: 프라이머리 키를 제외한 나머지 모든 인덱스이다.

데이터 저장으로 구분할 경우 대표적으로 B-Tree 인덱스와 Hash 인덱스로 구분 할 수 있다.

## 8.3 B-Tree 인덱스

데이터베이스의 인덱싱 알고리즘 가운데 가장 보편적으로 사용되는 알고리즘아다.  일반적으로 DBMS에서는 변형된 형태인 B+-Tree 또는 B*-Tree가 사용된다. B-Tree는 칼럼의 원래값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.

### 8.3.1 구조 및 특성

B-Tree는 트리 구조의 최상위에 하나의 루트노드가 존재하고 하위에 자식 노드가 붙어있는 형태이다. 가장 하위에 있는 노드를 리프노드,. 중간 노드를 브랜치 노드라고 한다.

인덱스와 실제 데이터가 저장된 데이터는 따로 관리 되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있다.

인덱스의 키값을 정렬되어있지만, 데이터 파일의 레코드는 임의의 순서로 저장되어있다. 레코드가 삭제되어 생기는 빈 공간을 재활용하도록 DBMS가 설계했기 때문이다.



- MyISAM과 InnoDB 스토리지 엔진의 인덱스에서 가장 큰 차이점은 세컨더리 인덱스를 통해 데이터 파일의 레코드를 찾아가는 방법이다.
- MyISAM 테이블은 세컨더리 인덱스가 물리적인 주소를 가지는 반면 InnoDB 테이블은 프라이머리 키를 주소처럼 사용하기 때문에 논리적인 주소를 가진다고 볼 수 있다.
- InnoDB에서는 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해 프라이머리 키를 저장하는 B-Tree를 다시 한번 검색해야한다.

### 8.3.2

B-Tree에 저장 될 때 저장된 키를 이용해 B-Tree상에 적절한 위치를 검색해야하는데 이때 리프노드가 꽉 찼을 경우 split하는 과정에서 처리 범위가 상위 노드까지 넓어질 수 있다. 따라서 InnoDB 스토리지 엔진은 필요하다면 인덱스 키 추가 작업을 지연시켜 나중에 처리할 수 이싿. 하지만 PK나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 추가 또는 삭제한다.

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

B-Tree 인덱스는 인덱스를 구성하는 칼럼의 크기와 레코드의 건수, 그리고 유니크한 인덱스 키 값의 개수 등에 의해 검색이나 변경 작업의 성능이 영향을 받는다.

1. 인덱스 키 값의 크기
- InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지 또는 블록이라고 하며, 이는 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위. 인덱스도 페이지 단위로 관리된다.
- 페이지의 크기의 기본 단위는 16KB이다. 인덱스를 구성하는 키 값이 커진다면 그만큼 디스크로부터 읽어야하는 횟수가 늘어나고 그만큼 느려지게 된다.
- 인덱스 키값의 길이가 길어져서 레코드를 위한 인덱스 크기가 커진다면 메모리에 캐시해 둘 수 있는 레코드의 수가 줄어들기 때문에 메모리의 효율이 떨어진다.
1. B-Tree 깉이
- B-Tree의 깊이는 값을 검색할때 몇번이나 랜덤하게 디스크를 읽어야하는지 직결되는 문제이다. 인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어진다.
- 따라서 같은 레코드 건수라 하더라도 B-Tree의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게 된다.
- 아무리 대용량 데이터베이스라도 깊이가 5단계 이상 깊어지는 경우는 흔치 않다.
1. 선택도(기구성)
- 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다. 전체 인덱스 키 값이 100개인데 그중 유니크 한 값의 수가 10개라면 기수성은 10이다.
- 인덱스는 선택도가 높을 수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.
- 선택도가 좋지 않더라도 정렬이나 그루핑 같은 작업을 위해 인덱스를 만드는 것이 훨씬 나은 경우도 있다. 인덱스가 항상 검색에만 사용되는 것은 아니므로 여러 가지 용도를 고려해 적절히 인덱스를 설계할 필요가 있다.
1. 읽어야하는 레코드의 건수
- 인덱스를 통해 레코드 1건을 읽는 것은 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 많이드는 작업이다.
- 따라서 인덱스를 통해 읽어야할 레코드이 건수가 인덱스의 손익 분기점인 20~25%보다 크면 MySQL 옵티마이저는 인덱스를 이용하지 않고 직접 테이블을 처음부터 끝까지 읽어서 처리하르 것이다.

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

MySQL이 인덱스를 이용하는 대표적인 방법 세가지가 있다.

1. 인덱스 레인지 스캔

   가장 대표적인 접근 방식으로, 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다.

2. 인덱스 풀 스캔

   인덱스의 처음부터 끝까지 모두 읽는 방식을 인덱스 풀 스캔이라고 한다. 대표적으로 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다.

   쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우 주로 이 방식이 사용된다.

3. 루스 인덱스 스캔

   5.7 버전까지는 제한적이나 8.0부터 다른 상용 DBMS에서 지원하는 인덱스 스킵 스캔과 같은 최적화를 조금씩 지원하기 시작했다.

   타이트 인덱스 스캔인 앞의 두가지 방법과 달리 루스 인덱스 스캔은 중간에 필요치 않은 인덱스 키값은 무시하고 다음으로 넘어가는 형태로 처리한다.

   일반적으로 GROUP BY 또는 집합 함수 가운데 MAX(), MIN() 함수에 대해 최적화를 하는 경우 사용된다.


### 8.3.5 다중 칼럼 인덱스

두개 이상의 칼럼을 포함하는 인덱스이다. 인덱스의 두 번째 칼럼은 첫 번째 칼럼에 의존해서 정렬되어 있다. 따라서 인덱스 내에서 각 칼럼의 순서가 중요하다.

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

인덱스의 키 값이 오름차순으로 생성되어도 인덱스를 내림차순으로 읽을 수 있다. 반대도 마찬가지.

인덱스의 정렬

5.7 버전에는 칼럼 단위로 정렬 순서를 혼합(ASC, DESC 혼합)해서 인덱스를 생성할 수 없어 숫자 칼럼의 경우 -1을 곱하는 우회 방법을 사용했지만 8.0 버전 부터 (team_name ASC, user_score DESC) 와 같은 정렬 순서를 혼합한 인덱스를 생성할 수 있다.

인덱스의 스캔 방향

### 8.3.7 B-Tree 인덱스의 가용성과 효율성

1. 비교 조건의 종류와 효율성

   다중 칼럼 인덱스에서 각 칼럼의 순서와 그 칼럼에 사용된 조건이 동등비교인지 범위 조건인지에 따라 각 인덱스 칼럼의 활용 형태가 달라지진다.

   작업 범위를 결정하는 조건은 많으면 많을 수록 쿼리의 처리 성능을 높이지만 체크 조건을 많다고 해서 쿼리에 처리 성능을 높이지는 못한다. 오히려 쿼리 실행을 더 느리게 만들 때가 많다.


2 . 인덱스의 가용성

B-Tree 인덱스의 특징은 왼쪽 값에 기준해서(Left-most) 오른쪽 값이 정렬되어 있다는 것이다.

따라서 하나의 칼럼으로 검색해도 값의 왼쪽 부분이 없으면, 다중 칼럼 인덱스일 경우 왼쪽 칼럼의 값을 모르면 인덱스 레인지 스캔을 사용할 수 없다.

1. 가용성과 효율성 판단

   기본적으로 B-Tree 인덱스의 특성상 다음 조건에 대해서는 작업 범위 결정 조건으로 사용할 수 없다.

    - NOT-EQUAL로 비교된 경우(<>, NOT IN, NOT BETWEEN, IS NOT NULL)
    - LIKE ‘%??’ (앞부분이 아닌 뒷부분 일치) 형태로 문자열 패턴이 비교된 경우
    - 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우
        - ex> WHERE SUBSTRING(column, 1, 1) = ‘X’
    - NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
        - ex) WHERE column = deterministic_function()
    - 데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)
        - ex) WHERE char_column = 10
    - 문자열 데이터 타입의 콜레이션이 다른 경우

   다른 일반적인 DBMS에서는 NULL 값이 인덱스에 저장되지 않지만 MySQL에서는 NULL 값도 인덱스에 저장된다. WHERE column IS NULL 와 같은 조건도 작업 범위 결정 조건으로 인덱스를 사용한다.


## 8.4 R-Tree 인덱스

## 8.8 클러스터링 인덱스

### 8.8.1 클러스터링 인덱스

프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현한다.

프라이머리 키 값에 의해 레코드이 저장 위치가 변경되며, 값이 변경될 경우 해당 레코드의 물리적인 저장 위치가 바뀌어야 한다는 것을 의미한다.

MySQL에서 클러스터링 인덱스는 InnoDB 스토리지 엔진에서만 지원하며, 나머지 스토리지 엔진에서는 지원되지 않는다. InnoDB와 같이 클러스터링 인덱스로 저정되는 테이블은 프라이머리 키 가반의 검색이 매우 빠르며, 대신 레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느리다.

세컨더리 인덱스를 위한 B-Tree의 리프 노드와는 달리 클러스터링 인덱스의 리프 노드에는 레코드의 모든 칼럼이 같이 저장되어있다.

프라이머리 키가 없는 경우 InnoDB 스토리지 엔진이 다음 우선순위대포 프라이머리 키를 대체할 칼럼을 선택한다.

1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택
2. NOT NULL 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터링 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후, 클러스터링 키로 선택

### 8.8.2 세컨더리 인덱스에 미치는 영향

InnoDB 테이블에서 세컨더리 인덱스가 실제 레코드가 저장된 주소를 가지고 있다면 클러스터링 키 값이 변경될 때마다 데이터 레코드의 주소가 변경되고 그때마다 해당 테이블의 모든 인덱스에 저장된 주솟값을 변경해야 할 것이다. 이런

### 8.8.3 클러스터링 인덱스의 장점과 단점

- 장점
    - 프라이머리 키로 검색할 떄 처리 성능이 매우 빠름
    - 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음
- 단점
    - 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있어 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 터짐
    - 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느림
    - INSERT할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
    - 프라이머리 키를 변경할 때 레코르를 DELETE하고 INSERT하는 작업이 필요하기 때문에 처리 성능이 느림

즉 빠른 읽기와 느린쓰기의 특징이 있다. 일반적으로 OLTP 에서는 읽기의 비율이 쓰기의 비율보다 훨씬 높으므로 읽기를 빠르게 유지하는 것이 중요하다.

### 8.8.4 클러스터링 테이블 사용 시 주의사항

1. 클러스터링 인덱스 키의 크기

   클러스터링 테이블의 경우 모든 세컨더리 인덱스가 프라이머리 키(클러스터링 키) 값을 포함한다. 그래서 프라이머리 키의 크기가 커진다면 세컨더리 인덱스도 자동으로 크기가 커진다. 하지만 프라이머리 키의 크기가 커지면 세컨더리 인덱스도 자동으로 크기가 커진다.

2. 프라이머리 키는 AUTO-INCREMENT보다는 업무적인 칼럼으로 생성

   해당 레코드를 대표할 수 있다는 그 칼럼을 프라이머리 키로 설정하는 것이 좋다.

3. 프라이머리 키는 반드시 명시할 것

   InnoDB 테이블에서 프라이머리 키를 정의하지 않으면 InnoDB 스토리지 엔진이 내부적으로 일련변호 칼럼을 추가하지만, 자동으로 추가된 칼럼은 사용자에게 보이지 않기 때문에 사용자가 접근할 수가 없다.

4. AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우

   프라이머리 키의 크기가 길어도 세컨더리 인덱스가 필요치 않다면 그대로 프라이머리 키를 사용하는 것이 좋다. 세컨더리 인덱스도 필요하고 프라이머리 키의 크기도 길다면 AUTO_INCREMENT 칼럼을 추가하고, 이를 프라이머리 키로 설정하면 된다.

   로그 테이블과 같은 INSERT 위주의 테이블은 인조 식별자를 프라이머리 키로 설정하는 것이 성능향상에 도움이 된다.
