# 8. 인덱스

# 8.1 디스크 읽기 방식

데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건일때가 상당히 많다.

## 8.1.1 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)

- 컴퓨터에서 CPU나 메모리 같은 주요 장치는 대부분 전자식 장치지만 하드 디스크 드라이브는 기계식 장치다. 이러한 하드 디스크 드라이브를 대체하기 위해 전자식 저장 매체인 SSD가 많이 출시되고 있다.
- SSD도 기존 하드 디스크 드라이브와 같은 인터페이스를 지원하므로 내장 디스크 DAS 또는 SAN에 사용가능함.
- 하드 디스크 드라이브에서 데이터 저장용 플래터를 제거하고 플래시 메모리를 장착하고 있어, 기계적으로 회전 시킬 필요가 없고 빠르게 데이터를 읽고 쓸 수 있다.
- 플래시 메모리는 전원이 꺼져도 데이터가 보존됨.
- 기존 하드 디스크 드라이브보다 랜덤 I/O가 훨씬 빠르기 때문에 요즘엔 DBMS용으로 사용할 서버에는 대부분 SSD를 채택하고 있다.

## 8.1.2 랜덤 I/O와 순차 I/O

- HDD의 플래터를 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는것을 의미 이것은 순차 I/O와 동일하다. 그리고 여러번 쓰기, 읽기를 요청하는 랜덤 I/O작업이 부하가 훨씬 더 크다.
- 원판이 없는 SSD같은 경우에는 랜덤과 순차 I/O의 차이가 없을것으로 예측하지만, 실제로는 랜덤 I/O가 성능이 떨어진다.
- 결론적으로는 쿼리를 튜닝한다의 의미는 랜덤 I/O자체를 줄인다. 즉, 쿼리를 처리하는데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미한다.

# 8.2 인덱스란?

- DBMS에서 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 키와 값의 쌍으로 삼아 인덱스를 만들어 두는것이다. 또한 칼럼의 값을 주어진 순서로 미리 정렬해서 보관.
- DBMS의 인덱스도 SortedList와 마찬가지로 저장되는 값을 이용해 항상 정렬된 상태를 유지, 데이터 파일은 ArrayList와 같이 저장된 순서대로 별도의 정렬없이 그대로 저장해 둔다.
- 위에서 SortedList와 ArrayList로 비유를 했는데, 단점도 유사하다. DBMS는 SortedList와 같이 저장하는 과정이 느리고, 찾는 과정은 빠르다. DBMS도 `SELECT` 빼고는 처리가 느려진다.
- 결론적으로 DBMS의 인덱스는 데이터 저장 성능을 버리고, 읽기 속도를 높이는 기능이다.
- 데이터 저장 방식별로 구분할 경우 사실 상당히 많은 분류가 있지만 대표격으로 B-Tree 인덱스와 Hash 인덱스가 있다.
- 데이터의 중복 허용으로 분류하면 유니크, 논 유니크로 구분할 수 있다. 이 기능은 옵티마이저에겐 상당히 중요한 문제가 된다. 이것 때문에 MySQL의 처리 방식의 변화나 차이점이 상당히 많다.

## 8.3 B-Tree 인덱스

- 데이터베이스의 인덱싱 알고리즘 가운데 가장 일반적으로 사용, 가장 먼저 도입된 알고리즘이며 현재까지도 가장 범용적으로 사용되는 인덱스 알고리즘.
- 칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서 항상 정렬된 상태 유지, 특수한 요건이 아닌 경우 대부분 이 알고리즘 사용

### 8.3.1 구조 및 특성

- 트리의 구조를 띄며, 데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리, 인덱스의 리프 노드는 항상 실 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있음.

### 8.3.2 B-Tree 인덱스 키 추가 및 삭제

### 8.3.2.1 인덱스 키 추가

1. 저장될 키 값을 이용해 B-Tree상의 적절한 위치를 검색.
2. 저장될 위치가 결정되면 레코드 키 값과 대상 레코드의 주소 정보를 리프 노드에 저장.
3. 리프 노드가 꽉 찰 경우, 리프 노드 분리가 필요. 상위 브랜치 노드까지 처리의 범위가 넒어짐.

### 8.3.2.2 인덱스 키 삭제

1. 리프 노드 찾아서
2. 삭제

### 8.3.2.3 인덱스 키 변경

1. 해당 키 값을 삭제
2. 새로운 키 값을 추가

### 8.3.2.4 인덱스 키 검색

- 트리 탐색을 이용해서 진행
- 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현 ⇒ 적절한 인덱스가 없으면 불필요하게 많은 레코드를 잠근다. 이래서 인덱스의 설계가 중요하다

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

- 인덱스를 구성하는 칼럼의 크기, 건수, 그리고 유니크한 인덱스 키 값의 개수 등에 의해 검색이나 변경 작업의 성능이 영향을 받는다.

### 8.3.3.1 인덱스 키 값의 크기

- 인덱스는 페이지 단위로 관리됨.
- B-Tree는 자식 노드의 개수가 가변적인 구조.
- 노드의 개수는 인덱스 페이지 크기와 키 값의 크기에 따라 결정된다.

### 8.3.3.2 B-Tree 깊이

- 인덱스의 깊이는 상당히 중요하지만 직접 제어할 방법은 없다.
- 인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어짐. ⇒ 디스크 읽기가 더 많이 필요하게 됨.
- 아무리 대용량 DB라 할지라도 5단계 이상까지 깊어지는 경우는 흔치 않다.

### 8.3.3.3 선택도

- 기수성이라고도 불린다. 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미.
- 결국 중복 값이 많아질수록 기수성은 낮아짐.

### 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

### 8.3.4.1 인덱스 레인지 스캔

- 인덱스 접근 방식 중 가장 대표적인 접근 방식, 뒤에 설명할 나머지 두가지 방식보다 빠른 방법
- 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
- 과정
    1. 인덱스 조건에 만족을 하는 값이 저장된 위치를 찾는다.
    2. 탐색된 위치부터 인덱스를 차례대로 쭉 읽는다.
    3. 위에서 읽어들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어 온다.
- 쿼리가 필요한 데이터에 따라 3번 과정을 생략 가능한데, 이를 커버링 인덱스라 한다. 커버링 인덱스로 처리되는 쿼리는 레코드를 읽지 않아도 되기 때문에 랜덤 읽기가 상당히 줄어들고 그만큼 빨라진다.

### 8.3.4.2 인덱스 풀 스캔

- 인덱스 레인지 스캔과 마찬가지로 인덱스를 사용, 하지만 레인지 스캔과 다르게 처음부터 끝까지 모두 읽는 방식을 인덱스 풀 스캔이라고 한다.
- 레인지 스캔보다는 빠르지 않지만, 테이블 풀 스캔보다는 효율적이다.

### 8.3.4.3 루스 인덱스 스캔

- 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미한다. 앞에 설명한 두 스캔방식은 타이트 인덱스 스캔이라고 불린다.
- 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리.
- 일반덕으로 Group by 또는 집합 삼수 가운데 MAX() or MIN() 함수에 대해 최적화를 하는 경우에 사용.

### 8.3.4.4 인덱스 스킵 스캔

- MySQL 8.0  버전에서 새로이 도입된 기능
- 인덱스의 선행 칼럼이 가진 유니크한 값의 개수가 소량일 때만 적용 가능한 최적화
- 다음과 같은 단점이 있음
    - WHERE 조건 절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함.
    - 쿼리가 인덱스에 존재하는 칼럼만으로 가능해야함.

### 8.3.5 다중 칼럼 인덱스

- 2개 이상의 칼럼으로 구성된 인덱스를 다중 칼럼 인덱스라 한다.
- 데이터 레코드 건수가 작은 경우에는 브랜치 노드가 없는 경우도 있을 수 있다.
- 인덱스 내에서 각 칼럼의 위치가 상당히 중요하다.

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

- 인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어 내는 실행 계획에 따라 결정

### 8.3.6.1 인덱스의 정렬

- 일반적인 사용 DBMS에서는 인덱스를 생성하는 시점에 인덱스를 구성하는 각 칼럼의 정렬을 오름차순 또는 내림차순으로 설정할 수 있다.
- MySQL 8.0부터는 정렬 순서를 혼합한 인덱스도 생성할 수 있게 됐다.

### 8.3.7 B-Tree 인덱스의 가용성과 효율성

- 쿼리의 WHERE 조건이나 GROUP BY, 또는 ORDER BY 절이 어떤 경우에 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지 식별할 수 있어야 함.
- 그래야 조건을 최적화하거나 역으로 쿼리에 맞게 인덱스를 최적으로 생성할 수 있음.

### 8.3.7.1 비교 조건의 종료와 효율성

- 작업 범위를 결정하는 조건은 많으면 많을수록 쿼리의 처리 성능을 높이지만 체크 조건은 많다고 해서 처리 성능을 높이지는 못한다. 오히려 느리게 만들 때가 많다.

### 8.3.7.2 인덱스의 가용성

- B-Tree 인덱스의 특징은 왼쪽 값에 기준해서 오른쪽 값이 정렬돼 있다.
- 완쪽이란 하나의 칼럼 내에서뿐만 아니라 다중 칼럼 인덱스의 칼럼에 대해서도 적용.

## 8.4 R-Tree 인덱스

B-Tree 인덱스를 구성하는 칼럼의 값이 1차원의 스칼라 값인 반면, R-Tree 인덱스는 2차원의 공간 개념 값이다.

### 8.4.1 구조및 특성

- 공간을 MBR로 분할하여 저장.
- MBR끼리는 겹칠 수 있고, 상위 레벨의 MBR은 하위 레벨의 MBR을 포함하는 Hierarchical Tree Structure이다.

### 8.4.2 R-Tree 인덱스의 용도

- 일반적으로 GPS 기준의 위도 경도 좌표 저장에 주로 사용.
- CAD/CAM 소프트웨어 또는 회로 디자인 등과 같이 좌표 시스템에 기반을 둔 정보에 모두 적용 가능
- `ST_Contations()` `ST_Wuthin()` 함수를 사용함.

## 8.5 전문 검색 인덱스

### 8.5.1 인덱스 알고리즘

- 전문 검색에서는 문서 본문의 내용에서 사용자가 검색하게 될 키워드를 분석해 내고, 빠른 검색용으로 사용할 수 있게 이러한 키워드로 인덱스를 구축.

### 8.5.1.1 어근 분석 알고리즘

- 전문 검색 인덱스는 불용어 처리, 어근 분석과 같은 두 가지 중요한 과정을 거쳐서 색인 작업이 수행된다.
- 불용어 처리는 검색에서 별 가치가 없는 단어를 모두 필터링해서 제거하는 작업을 의미.
- 어근 분석은 검색어로 선정된 단어의 뿌리인 원형을 찾는 작업.

### 8.5.1.2 n-gram 알고리즘

- MeCab을 위한 형태소 분석은 매우 전문적인 전문 검색 알고리즘 이어서 만족할 만한 결과를 내기 위해서는 많은 노력과 시간을 필요로 한다. 또한 전문적인 검색 엔진을 고려하는 것이 아니라면 범용적으로 적용하기는 쉽지 않다.
- 이런 단점을 보완하기 위한 방법이 n-gram 알고리즘이다.
- 이 알고리즘은 무조건 몇 글자씩 잘라서 인덱싱하는 방법.
- 형태소 분석보다 단순하고 국가별 언어에 대한 이해와 준비 작업이 필요 없긴 하지만, 만들어진 인덱스의 크기는 상당히 큰 편.

### 8.5.1.3 불용어 변경 및 삭제

- 특정 불용어 처리는 사용자에게 도움이 되기 보다는 사용자를 더 혼란스럽게 하는 기능일 수도 있다. 그래서 불용어 처리 자체를 완전히 무시하거나 MySQL 서버에 내장된 불용어 대신 사용자가 직접 불용어를 등록하는 방법을 권장.

### 8.5.2 전문 검색 인덱스의 가용성

- 전문 검색 인덱스를 사용하려면, 쿼리 문장이 전문 검색을 위한 문법을 사용하고 테이블이 전문 검색 대상 칼럼에 대해서 전문 인덱스 보유

## 8.6 함수 기반 인덱스

- 칼럼의 값을 변형해서 만들어진 값에 대해 인덱스를 구축해야 할 때 사용
- 구현하는 방법은 2가지 있는데, 가상 칼럼을 이용한 인덱스, 함수를 이용한 인덱스로 구분할 수 있다.
- 인덱싱 값을 계산하는 과정의 차이만 있을 뿐, 실제 인덱스의 내부적인 구조 및 유지 관리 방법은 B-Tree 인덱스와 동일

### 8.6.1 가상 칼럼을 이용한 인덱스

- 15.8절 ‘가상 칼럼(파생 칼럼)’에서 자세히 살펴봄.

## 8.7 멀티 밸류 인덱스

- 하나의 데이터 레고드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스

## 8.8 클러스터링 인덱스

- 클러스터링은 군집화의 의미로 여러 개를 하나로 묶는다는 의미로 주로 사용하고 여기서도 크게 벗어나지 않는다.

### 8.8.1 클러스터링 인덱스

- 테이블의 프라이머리 키에 대해서만 적용되는 내용.
- 프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현.
- 프라이머이 키 값으로 클러스터링된 테이블은 프라이머리 키 값 자체에 대한 의존도가 상당히 크기 대문에 신중히 프라이머리 키를 결정해야함.

### 8.8.2 세컨더리 인덱스에 미치는 영향

- InnoDB에서는 클러스터링 키 값이 변경될 때마다 데이터 레코드의 주소가 변경되고 그때마다 해당 테이블의 모든 인덱스에 저장된 주솟값을 변경해야 할 것이다.
- 위에서 설명하고 있는 이유 때문에 InnoDB 테이블의 모든 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 구현.

### 8.8.3 클러스터링 인덱스의 장점과 단점

- 대부분 클러스터링 인덱스의 장점은 빠른 읽기, 잔점은 느린 쓰기이다.

### 8.8.4 클러스터링 테이블 사용 시 주의사항

### 8.8.4.1 클러스터링 인덱스 키의 크기

- 클러스터링 테이블의 경우 모든 세컨더리 인덱스가 프라이머리 키 값을 포함.
- 위와 같은 이유로 프라이머리 키의 크기가 커지면 세컨더리 인덱스도 자동으로 커짐.
- 따라서 한 인덱스가 커질수록 같은 성능을 내기 위해 그만큼의 메모리가 더 필요해지므로 InnoDB 테이블의 프라이머리 키는 신중하게 선택.

### 8.8.4.2 프라이머리 키는 Auto-Increment보다는 업무적인 칼럼으로 생성(가능한 경우)

- InnoDB의 프라이머리 키는 클러스터링 키로 사용되며, 이 값에 의해 레코드의 위치가 결정. 따라서 읽기가 비교적 빠르다.
- 프라이머리 키는 그 의미만큼이나 중요한 역할을 하기 때문에 대부분 검색에서 상당히 빈번하게 사용되는 것이 일반적이다.
- 칼럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 그 칼럼을 프라이머리 키로 설정하는 것이 좋다.

### 8.8.4.3 프라이머리 키는 반드시 명시할 것.

- 프라이머리 키가 없으면 내부적으로 일련 번호 칼럼을 추가하는데, 이러면 보이지 않기 대문에 사용자가 전혀 접근할 수 가 없다.

### 8.8.4.4 Auto-increment 칼럼을 인조 식별자로 사용할 경우

- 세컨더리 인덱스도 필요하고 프라이머리 키의 크기도 길다면 Auto-increment 칼럼을 추가하고, 이를 프라이머리 키로 설정하자!
- 위와 같이 프라이머리 키를 대체하기 위해 인위적으로 추가된 프라이머리 키를 인조 식별자라고 한다. 그리고 이것을 프라이머리 키로 설정하는 것이 성능 향상에 도움이 된다.

## 8.9 유니크 인덱스

- 유니크는 사실 인덱스라기 보다 제약 조건에 가깝다고 볼 수 있다.
- 테이블이나 인덱스에 같은 값이 2개 이상 저장될 수 없음을 의미.

### 8.9.1 유니크 인덱스와 일반 세컨더리 인덱스의 비교

### 8.9.1.1 인덱스 읽기

- 유니크 인덱스가 빠르지 않다.
- 읽어야 할 레코드 건수가 같다면 성능상의 차이는 미미하다.

### 8.9.1.2 인덱스 쓰기

- 중복된 값이 있는지 없는지 체크하는 과정이 한 단계 더 필요하다. 그래서 유니크하지 않은 세컨더리 인덱스의 쓰기보다 느리다.
- 또한 작업 자체를 중복 체크 때문에 버퍼링하지 못하므로 변경 작업이 더 느리게 작동.

### 8.9.2 유니크 인덱스 사용 시 주의사항

- 유일성이 곡 보장돼야 하는 칼럼에 대해선 유니크 인덱스를 생성하되, 꼭 필요하지 않다면 유니크하지 않은 세컨더리 인덱스를 생성하는 방법도 한 번씩 고려해 보자.

## 8.10 외래키

- MySQL에선 오직 InnoDB에서만 생성
- 외래키 제약이 설정되면 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성.
- 외래키가 제거되지 않은 상태에서 자동으로 생성된 인덱스 삭제 X
- 외래키 관리에는 테이블의 변경이 발생하는 경우에만 잠근 경합이 발생하는 것과 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠근 경합 발생시키지 않는 특징이 있다.

### 8.10.1 자식 테이블의 변경이 대기하는 경우

- 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려 있으면 해당 쓰기 잠금이 해제될 때까지 기다리게 되는 것
- 자식 테이블의 외래키가 아닌 칼럼의 변경은 외래키로 인한 잠금 확장이 발생하지 않습니다.

### 8.10.2 부모 테이블의 변경이 대기하는 경우

물리적인 외래키의 고려 사항은, 이러한 체크 작업이 아니라 이런 체크를 위해 연관 테이블에 읽기 잠금을 걸어야 하고 잠금이 다른 테이블로 확장되면 그만큼 전체적으로 쿼리의 동시 처리에 영향을 미치게 됩니다.